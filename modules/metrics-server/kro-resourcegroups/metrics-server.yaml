apiVersion: kro.run/v1alpha1
kind: ResourceGraphDefinition
metadata:
  name: metrics-server
spec:
  schema:
    apiVersion: v1alpha1
    kind: MetricsServer
    group: metrics.company.com
    spec:
      # Configuration
      namespace: string | default="kube-system"
      replicas: integer | default=2

      # Resource Configuration
      cpuRequest: string | default="100m"
      memoryRequest: string | default="200Mi"
      cpuLimit: string | default="500m"
      memoryLimit: string | default="1Gi"

      # High Availability
      enablePDB: boolean | default=true

  resources:
    # ServiceAccount
    - id: metricsServerSA
      template:
        apiVersion: v1
        kind: ServiceAccount
        metadata:
          name: metrics-server
          namespace: ${schema.spec.namespace}
          labels:
            app.kubernetes.io/name: metrics-server
            app.kubernetes.io/managed-by: kro

    # ClusterRole
    - id: metricsServerClusterRole
      template:
        apiVersion: rbac.authorization.k8s.io/v1
        kind: ClusterRole
        metadata:
          name: system:metrics-server
          labels:
            app.kubernetes.io/name: metrics-server
        rules:
          - apiGroups: [""]
            resources: ["nodes/metrics"]
            verbs: ["get"]
          - apiGroups: [""]
            resources: ["pods", "nodes"]
            verbs: ["get", "list", "watch"]

    # ClusterRoleBinding
    - id: metricsServerCRB
      template:
        apiVersion: rbac.authorization.k8s.io/v1
        kind: ClusterRoleBinding
        metadata:
          name: system:metrics-server
          labels:
            app.kubernetes.io/name: metrics-server
        roleRef:
          apiGroup: rbac.authorization.k8s.io
          kind: ClusterRole
          name: system:metrics-server
        subjects:
          - kind: ServiceAccount
            name: metrics-server
            namespace: ${schema.spec.namespace}

    # ClusterRole for aggregated API
    - id: metricsServerAggregatedRole
      template:
        apiVersion: rbac.authorization.k8s.io/v1
        kind: ClusterRole
        metadata:
          name: system:aggregated-metrics-reader
          labels:
            app.kubernetes.io/name: metrics-server
            rbac.authorization.k8s.io/aggregate-to-view: "true"
            rbac.authorization.k8s.io/aggregate-to-edit: "true"
            rbac.authorization.k8s.io/aggregate-to-admin: "true"
        rules:
          - apiGroups: ["metrics.k8s.io"]
            resources: ["pods", "nodes"]
            verbs: ["get", "list", "watch"]

    # Role for auth-reader
    - id: metricsServerAuthReaderRole
      template:
        apiVersion: rbac.authorization.k8s.io/v1
        kind: RoleBinding
        metadata:
          name: metrics-server-auth-reader
          namespace: kube-system
          labels:
            app.kubernetes.io/name: metrics-server
        roleRef:
          apiGroup: rbac.authorization.k8s.io
          kind: Role
          name: extension-apiserver-authentication-reader
        subjects:
          - kind: ServiceAccount
            name: metrics-server
            namespace: ${schema.spec.namespace}

    # ClusterRoleBinding for auth-delegator
    - id: metricsServerAuthDelegator
      template:
        apiVersion: rbac.authorization.k8s.io/v1
        kind: ClusterRoleBinding
        metadata:
          name: metrics-server:system:auth-delegator
          labels:
            app.kubernetes.io/name: metrics-server
        roleRef:
          apiGroup: rbac.authorization.k8s.io
          kind: ClusterRole
          name: system:auth-delegator
        subjects:
          - kind: ServiceAccount
            name: metrics-server
            namespace: ${schema.spec.namespace}

    # APIService
    - id: metricsAPIService
      template:
        apiVersion: apiregistration.k8s.io/v1
        kind: APIService
        metadata:
          name: v1beta1.metrics.k8s.io
          labels:
            app.kubernetes.io/name: metrics-server
        spec:
          service:
            name: metrics-server
            namespace: ${schema.spec.namespace}
          group: metrics.k8s.io
          version: v1beta1
          insecureSkipTLSVerify: true
          groupPriorityMinimum: 100
          versionPriority: 100

    # Service
    - id: metricsServerService
      template:
        apiVersion: v1
        kind: Service
        metadata:
          name: metrics-server
          namespace: ${schema.spec.namespace}
          labels:
            app.kubernetes.io/name: metrics-server
        spec:
          type: ClusterIP
          ports:
            - port: 443
              protocol: TCP
              targetPort: https
              name: https
          selector:
            app.kubernetes.io/name: metrics-server

    # Deployment
    - id: metricsServerDeployment
      template:
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: metrics-server
          namespace: ${schema.spec.namespace}
          labels:
            app.kubernetes.io/name: metrics-server
        spec:
          replicas: ${schema.spec.replicas}
          strategy:
            type: RollingUpdate
            rollingUpdate:
              maxUnavailable: 1
          selector:
            matchLabels:
              app.kubernetes.io/name: metrics-server
          template:
            metadata:
              labels:
                app.kubernetes.io/name: metrics-server
            spec:
              serviceAccountName: metrics-server
              priorityClassName: system-cluster-critical
              securityContext:
                runAsNonRoot: true
                runAsUser: 1000
                fsGroup: 1000
                seccompProfile:
                  type: RuntimeDefault
              containers:
                - name: metrics-server
                  image: registry.k8s.io/metrics-server/metrics-server:v0.7.0
                  imagePullPolicy: IfNotPresent
                  args:
                    - --cert-dir=/tmp
                    - --secure-port=4443
                    - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname
                    - --kubelet-use-node-status-port
                    - --metric-resolution=15s
                  ports:
                    - name: https
                      containerPort: 4443
                      protocol: TCP
                  livenessProbe:
                    httpGet:
                      path: /livez
                      port: https
                      scheme: HTTPS
                    initialDelaySeconds: 20
                    periodSeconds: 10
                    failureThreshold: 3
                  readinessProbe:
                    httpGet:
                      path: /readyz
                      port: https
                      scheme: HTTPS
                    initialDelaySeconds: 20
                    periodSeconds: 10
                    failureThreshold: 3
                  resources:
                    requests:
                      cpu: ${schema.spec.cpuRequest}
                      memory: ${schema.spec.memoryRequest}
                    limits:
                      cpu: ${schema.spec.cpuLimit}
                      memory: ${schema.spec.memoryLimit}
                  securityContext:
                    allowPrivilegeEscalation: false
                    readOnlyRootFilesystem: true
                    runAsNonRoot: true
                    runAsUser: 1000
                    capabilities:
                      drop:
                        - ALL
                  volumeMounts:
                    - name: tmp-dir
                      mountPath: /tmp
              volumes:
                - name: tmp-dir
                  emptyDir: {}
              nodeSelector:
                kubernetes.io/os: linux
              affinity:
                podAntiAffinity:
                  preferredDuringSchedulingIgnoredDuringExecution:
                    - weight: 100
                      podAffinityTerm:
                        labelSelector:
                          matchLabels:
                            app.kubernetes.io/name: metrics-server
                        topologyKey: kubernetes.io/hostname

    # PodDisruptionBudget
    - id: metricsServerPDB
      includeWhen:
        - ${schema.spec.enablePDB}
      template:
        apiVersion: policy/v1
        kind: PodDisruptionBudget
        metadata:
          name: metrics-server
          namespace: ${schema.spec.namespace}
          labels:
            app.kubernetes.io/name: metrics-server
        spec:
          minAvailable: 1
          selector:
            matchLabels:
              app.kubernetes.io/name: metrics-server
